---
layout:     post
title:      KMP
subtitle:   Knuth-Morris-Pratt Algorithm
date:       2021-05-11
author:     Huang
header-img: img/home-bg-geek.jpg
catalog: true
tags:
   - Programming
   - Algorithms
---

> 查找子字符串位置

#### 引言

参考文章中已经将KMP算法讲得十分明白，在这里我想要着重强调几点。

#### 主体

##### 1. `next[]` vs. `nextval[]`

* `nextval[]`是`next[]`经过优化后的数组
* 优化的地方是：模式串的与text文本比较的字符(红b) 与经过 平移后的字符(蓝b) 一样，会造成已经访问过的模式串的利用不充分

![模式](https://imgconvert.csdnimg.cn/aHR0cDovL2hpLmNzZG4ubmV0L2F0dGFjaG1lbnQvMjAxMTA2LzE0LzgzOTQzMjNfMTMwODA3NTg1NzE0bFcuanBn?x-oss-process=image/format,png)

##### 2. 求next[]时，不匹配的时候的反溯


![recursive](https://img-blog.csdn.net/20150812214857858)

![recursive](https://img-blog.csdnimg.cn/20200820183256674.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92,size_16,color_FFFFFF,t_70)

主要需要理解上面两点，其他的仔细看看代码就都能够明白了。

##### C++代码实现

```c++
/* Author: huang-feiyu@GitHub*/
#include <iostream>

#include <string>

using namespace std;

// next[] array
void Get_next(string pattern, int next[]) {
    int tmp_string_length = pattern.length();
    int tmp_k = -1; // value
    int tmp_p = 0; // pointer
    // first one must be -1
    next[tmp_p] = tmp_k;
    while (tmp_p < tmp_string_length - 1) {
        // one char match
        if (tmp_k == -1 || pattern[tmp_k] == pattern[tmp_p]) {
            tmp_k++;
            tmp_p++;
            next[tmp_p] = tmp_k;
        } else {
            // this one do not match, recursive
            tmp_k = next[tmp_k];
        }
    }
}

// nextval[] array, optimism
void Get_nextval(string pattern, int next[]) {
    int tmp_string_length = pattern.length();
    int tmp_k = -1;
    int tmp_p = 0;
    next[tmp_p] = tmp_k;
    while (tmp_p < tmp_string_length - 1) {
        if (tmp_k == -1 || pattern[tmp_k] == pattern[tmp_p]) {
            tmp_k++;
            tmp_p++;
            // optimism
            if (pattern[tmp_k] != pattern[tmp_p]) {
                next[tmp_p] = tmp_k;
            } else {
                next[tmp_p] = next[tmp_k];
            }
        } else {
            tmp_k = next[tmp_k];
        }
    }
}

// KMP search
int KMP_search(string text, string pattern, int next[]) {
    for (int i = 0; i < pattern.length() - 1; i++) {
        next[i] = 0;
    }
    Get_nextval(pattern, next);
    int text_length = text.length();
    int pattern_length = pattern.length();
    int tmp_p = 0; // pointer to pattern string
    int tmp_t = 0; // pointer to text string
    while (tmp_p < text_length && tmp_t < text_length) {
        if (tmp_p == -1 || pattern[tmp_p] == text[tmp_t]) {
            tmp_p++;
            tmp_t++;
        } else {
            // pointer back
            tmp_p = next[tmp_p];
        }
    }
    if (tmp_p == pattern_length) {
        return tmp_t - tmp_p;
    } else {
        return -1;
    }
}

// KMP
int KMP(string text, string pattern) {
    int next[pattern.length()];
    return KMP_search(text, pattern, next);
}

int main(void) {
    string text = "ABDCEF";
    string pattern = "EF";
    cout << "location: should be 4" << endl;
    cout << "algorithm location: " << KMP(text, pattern) << endl;
    return 0;
}
```

#### 参考：

[1] [CSDN：从头至尾理解KMP算法](https://blog.csdn.net/v_JULY_v/article/details/7041827)

[2] [Wikipedia: KMP](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm)

