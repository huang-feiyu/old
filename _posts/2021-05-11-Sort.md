---
layout:     post
title:      Sort
subtitle:   五种简单的排序算法
date:       2021-05-11
author:     Huang
header-img: img/post-bg-2015.jpg
catalog: true
tags:
   - Programming
   - Algorithms
---

> 五种排序算法的简单解释

#### 引言

排序算法应用十分广泛。

自从计算机科学开始发展，排序算法就在所有的科学家的研究范围之内。甚至[Knuth](https://en.wikipedia.org/wiki/Donald_Knuth)的巨著就有一册专门讨论排序与查找。

[菜鸟教程](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)
![比较](https://www.runoob.com/wp-content/uploads/2019/03/sort.png)

#### Bubble-Sort

冒泡排序，每一次大循环让最大的元素像气泡向上运动, 图源[菜鸟教程](https://www.runoob.com/w3cnote/bubble-sort.html)。

![Bubble Sort](https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif)

##### C++代码实现

```c++
/****************************************************************
 *  Description:   
 *      A element move upward like a Bubble
 *          
 *  Implementation notes:
 *
 *  Analysis:
 *      Space Complexity: O(1)
 *      Time Complexity: O(n^2)
 *
 *  Additional:
 *      1. 比较相邻的元素。不断将大的元素和小的元素交换，
 *         一对对的顺序比较，那么一次之后最大的元素肯定在最后
 *      2. 每次循环之后，后面的元素就不需要比较了
 *
 *  Author:
 *      git@huang-feiyu
 *
 *  Copyright: 
 *      Huang-Feiyu
 * 
 *  Licence:
 *      MIT Licence
 * 
 **************************************************************/

#include <vector>
#include <iostream>
using std::vector;
using std::cout;
using std::endl;

template <typename T>
void swap(T a, T b) {
}

template <typename T>
void sort(vector<T> & vec) {
    int size = vec.size();
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size - 1 - i; j++) {
            if (vec[j] > vec[j + 1]) {
                T temp = vec[j];
                vec[j] = vec[j + 1];
                vec[j + 1] = temp;
            }
        }
    }
}

int main(void) {
    vector<int> vec;
    vec.push_back(2);
    vec.push_back(5);
    vec.push_back(6);
    vec.push_back(3);
    vec.push_back(10);
    vec.push_back(4);
    vec.push_back(2);
    cout << "Initial vector: " << endl;
    for (int i = 0; i < vec.size(); i++) {
        cout << vec[i] << ", ";
    }
    cout << endl;
     
    sort(vec);
    cout << "Sorted vector: " << endl;
    for (int i = 0; i < vec.size(); i++) {
        cout << vec[i] << ", ";
    }
    cout << endl;

    return 0;
}
```

#### Insert-Sort

插入排序，就像打扑克一样。从头至尾扫遍，每一次都比较，插入到虚拟数组中。图源[菜鸟教程](https://www.runoob.com/w3cnote/insertion-sort.html).

![Insert-Sort](https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif)

##### C++代码实现

```c++
/****************************************************************
 *  Description:   
 *      A simple Sort, but not so simple
 *          
 *  Implementation notes:
 *      1. Select the first one, it is virtual array with only one 
 *         element. So the virtual array is sorted.
 *      2. Insert each element from 2 to end, each time insert element
 *         like Poke
 *
 *  Analysis:
 *      Space Complexity: O(1)
 *      Time Complexity: O(n^2)
 *
 *  Additional:
 *
 *  Author:
 *      git@huang-feiyu
 *
 *  Copyright: 
 *      Huang-Feiyu
 * 
 *  Licence:
 *      MIT Licence
 * 
 **************************************************************/

#include <vector>
#include <iostream>
using std::vector;
using std::cout;
using std::endl;

template <typename T>
void sort(vector<T> & vec) {
    int size = vec.size();
    // 第一个元素为已经排序好了的
    for (int i = 1; i < size; i++) {
        int j = i - 1;
        T key = vec[i];
        // 向后移动小于待排序元素vec[i]的虚拟数组元素
        while (j >= 0 && key < vec[j]) {
            vec[j + 1] = vec[j];
            j--;
        }
        vec[j + 1] = key;
    }
}

int main(void) {
    vector<int> vec;
    vec.push_back(2);
    vec.push_back(5);
    vec.push_back(6);
    vec.push_back(3);
    vec.push_back(10);
    vec.push_back(4);
    vec.push_back(2);
    cout << "Initial vector: " << endl;
    for (int i = 0; i < vec.size(); i++) {
        cout << vec[i] << ", ";
    }
    cout << endl;
     
    sort(vec);
    cout << "Sorted vector: " << endl;
    for (int i = 0; i < vec.size(); i++) {
        cout << vec[i] << ", ";
    }
    cout << endl;

    return 0;

```

#### Merge-Sort

归并排序，分而治之的算法，通过迭代实现。它为什么能够把加速排序呢？就是两个已经排序过的子数组，在合并成为一个大数组的时候是只需要比较队头元素的。

图源[菜鸟教程](https://www.runoob.com/w3cnote/merge-sort.html).

![Merge Sort](https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif)

##### C++代码实现

```c++
/****************************************************************
 *  Description:
 *      MergeSort, recursive, divide and conquer
 *
 *  Implementation notes: 
 *      递归基础: 矢量为空或者为一个元素
 *      递推: 二分为两个矢量, 同时排序并清空原矢量对象
 *      最后合并成一个矢量
 *
 *  Analysis:
 *      Space Complexity: O(N)
 *      Time Complexity: O(N * logN)
 *
 *  Additional:
 *
 *  Author:
 *      git@huang-feiyu
 *
 *  Copyright: 
 *      Huang-Feiyu
 * 
 *  Licence:
 *      MIT Licence
 * 
 **************************************************************/

#include <vector>
#include <iostream>
using std::vector;
using std::cout;
using std::endl;



template <typename T>
static void merge(vector<T>& vec, vector<T>& v1, vector<T>& v2) {
  int n1 = v1.size();
  int n2 = v2.size();
  int p1 = 0;
  int p2 = 0;

  while (p1 < n1 && p2 < n2) {
     if (v1[p1] < v2[p2]) {
         vec.push_back(v1[p1++]);
     } else {
         vec.push_back(v2[p2++]);
     }
   }

  while (p1 < n1) { vec.push_back(v1[p1++]); }
  while (p2 < n2) { vec.push_back(v2[p2++]); }
}

template <typename T>
static void sort(vector<T> & vec) {
  int n = vec.size();
  if (n <= 1) return;
  vector<T> v1;
  vector<T> v2;

  for (int i = 0; i < n; i++) {
     if (i < n / 2) {
        v1.push_back(vec[i]);
     } else {
        v2.push_back(vec[i]);
     }
  }
  sort(v1);
  sort(v2);
  vec.clear();
  merge(vec, v1, v2);
}


int main(void) {
    vector<int> vec;
    vec.push_back(2);
    vec.push_back(5);
    vec.push_back(6);
    vec.push_back(3);
    vec.push_back(10);
    vec.push_back(4);
    vec.push_back(2);
    cout << "Initial vector: " << endl;
    for (int i = 0; i < vec.size(); i++) {
        cout << vec[i] << ", ";
    }
    cout << endl;
     
    sort(vec);
    cout << "Sorted vector: " << endl;
    for (int i = 0; i < vec.size(); i++) {
        cout << vec[i] << ", ";
    }
    cout << endl;

    return 0;
}
```

#### Quick-Sort

快速排序。

选择一个基准元素(一般是第一个元素)，重新排序数组。根据基准值将数组分割为二，一部分是比基准值大的，一部分是比基准值小的。

递归地排序每一个子数组根据同样的方式排序。

图源[菜鸟教程](https://www.runoob.com/w3cnote/quick-sort-2.html).

![Quick Sort](https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif)

##### C++代码实现

```c++
/****************************************************************
 *  Copyright: 
 *      Huang-Feiyu
 *
 *  Author:
 *      git@huang-feiyu
 * 
 *  Licence:
 *      MIT Licence
 *
 *  Description:
 *      QuickSort, one of the best algorithms
 *  Implementation notes: 
 *      1. 选择一个大小元素之间的边界
 *      2. 对矢量中的元素重新排序，大的到末尾，小的到开头
 *      3. 将划分的每一部分矢量元素进行排序
 *
 *  Analysis:
 *      Space Complexity: O(1)
 *      Time Complexity: O(N * logN)
 *
 *  Additional:
 * 
 **************************************************************/

#include <vector>
#include <iostream>
using std::vector;
using std::cout;
using std::endl;

// 分隔
template <typename T>
int partition(vector<T> & vec, int start, int finish) {
    // 中间元素
    T pivot = vec[start];
    int lh = start + 1;
    int rh = finish;
    while (true) {
        while (lh < rh && vec[rh] >= pivot) rh--;
        while (lh < rh && vec[lh] < pivot) lh++;
        if (lh == rh) break;
        T tmp = vec[lh];
        vec[lh] = vec[rh];
        vec[rh] = tmp;
    }
    // special case: 所选择的元素就是最小元素
    if (vec[lh] >= pivot) return start;

    // 交换中间元素和最小元素
    vec[start] = vec[lh];
    vec[lh] = pivot;
    return lh;
}

// 快速排序: 递归算法
template <typename T>
void quickSort(vector<T> & vec, int start, int finish) {
    if (start >= finish) { return; }
    int boundary = partition(vec, start, finish);
    quickSort(vec, start, boundary - 1);
    quickSort(vec, boundary + 1, finish);
}

template <typename T>
void sort(vector<T> & vec) {
    quickSort(vec, 0, vec.size() - 1);
}



int main(void) {
    vector<int> vec;
    vec.push_back(2);
    vec.push_back(5);
    vec.push_back(6);
    vec.push_back(3);
    vec.push_back(10);
    vec.push_back(4);
    vec.push_back(2);
    cout << "Initial vector: " << endl;
    for (int i = 0; i < vec.size(); i++) {
        cout << vec[i] << ", ";
    }
    cout << endl;
    sort(vec);
    cout << "Sorted vector: " << endl;
    for (int i = 0; i < vec.size(); i++) {
        cout << vec[i] << ", ";
    }
    cout << endl;

    return 0;
}
```

#### Selection-Sort

选择排序，选择最小的元素一个个加入到数组中去。图源[菜鸟教程](https://www.runoob.com/w3cnote/selection-sort.html)

![Selection Sort](https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif)

##### C++代码实现

```c++
/****************************************************************
 *  Description:   
 *      Selection Sort, the simplest algorithm to sort
 *          
 *  Implementation notes: 
 *      1. Select the smallest element in the range between left hand and the
 *      end of the vector, and point at that element with right hand
 *      2. Move that element into its correct position by exchanging the
 *      elements indicated by left hand and right hand
 *
 *  Analysis:
 *      Space Complexity: O(1)
 *      Time Complexity: O(n^2)
 *
 *  Additional:
 *
 *  Author:
 *      git@huang-feiyu
 *
 *  Copyright: 
 *      Huang-Feiyu
 * 
 *  Licence:
 *      MIT Licence
 * 
 **************************************************************/

#include <vector>
#include <iostream>
using std::vector;
using std::cout;
using std::endl;

template <typename T>
void sort(vector<T> & vec) {
    int n = vec.size();
    for (int lh = 0; lh < n; lh++) {
        int rh = lh;
        // 选择出最小的元素
        for (int i = lh + 1; i < n; i++) {
            if (vec[i] < vec[rh]) { rh = i; }
        }
        T tmp = vec[lh];
        vec[lh] = vec[rh];
        vec[rh] = tmp;
    }
}

int main(void) {
    vector<int> vec;
    vec.push_back(2);
    vec.push_back(5);
    vec.push_back(6);
    vec.push_back(3);
    vec.push_back(10);
    vec.push_back(4);
    vec.push_back(2);
    cout << "Initial vector: " << endl;
    for (int i = 0; i < vec.size(); i++) {
        cout << vec[i] << ", ";
    }
    cout << endl;
     
    sort(vec);
    cout << "Sorted vector: " << endl;
    for (int i = 0; i < vec.size(); i++) {
        cout << vec[i] << ", ";
    }
    cout << endl;

    return 0;
}
```

